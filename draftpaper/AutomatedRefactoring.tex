\documentclass[conference,compsoc,a4paper]{IEEEtran}

\usepackage[utf8]{inputenc}
\usepackage[final]{pdfpages}
\usepackage[cmex10]{amsmath}
\usepackage{amssymb}
\usepackage{acronym}

\usepackage{xspace}
\usepackage{balance}

\usepackage[
  pdflang=en,
  colorlinks=true,
  unicode=true,
  pdfstartview=,
  allcolors=black
]{hyperref}
\hypersetup{
  pdftitle={Automated Refactoring},
  pdfauthor={Lisa Maria Kritzinger, Peter Feichtinger}
}

\newcommand{\code}[1]{{\small\ttfamily #1}}

\newcommand{\lk}[1]{\textcolor{orange}{[LK] #1}}
\newcommand{\pf}[1]{\textcolor{green}{[PF] #1}}


\begin{document}

\title{Automated Refactoring}
\author{
  \IEEEauthorblockN{Lisa Maria Kritzinger}
  \IEEEauthorblockA{Johannes Kepler University Linz\\
    1255353\\
    Email: \href{mailto:kritzinger@gmx.net}{kritzinger@gmx.net}}
  \and
  \IEEEauthorblockN{Peter Feichtinger}
  \IEEEauthorblockA{Johannes Kepler University Linz\\
    1056451\\
    Email: \href{mailto:shippo@gmx.at}{shippo@gmx.at}}
}

% make the title area
\maketitle


\begin{abstract}
Refactoring, the restructuring of a software system without changing its semantics, is essential in software evolution. 
Manual refactoring can be time-consuming and error-prone, so tool support is desirable when making large changes. In 
this article, we will explore a number of publications on automating different refactoring tasks, from just making code 
more compact to introducing objects into a C codebase.

Additionally, we will provide comparisons which will show the advantages and disadvantages of different approaches, 
regarding the performance of the software after refactoring, the applicability of a certain approach, or the simplicity 
of the application of an approach.


\end{abstract}

\begin{IEEEkeywords}
Software restructuring, automatic refactoring, tool support, software evolution.
\end{IEEEkeywords}

% For peer review papers, you can put extra information on the cover
% page as needed:
% \ifCLASSOPTIONpeerreview
% \begin{center} \bfseries EDICS Category: 3-BBND \end{center}
% \fi
%
% For peerreview papers, this IEEEtran command inserts a page break and
% creates the second title. It will be ignored for other modes.
\IEEEpeerreviewmaketitle


\section{Introduction}

Refactoring is the process of restructuring a software system without changing its semantics. It is used to increase 
readability and maintainability of software, reduce its complexity, or change the architecture of a system. Refactoring 
is essential in software evolution, because as a system is adapted to new requirements it inevitably becomes more 
complex and drifts away from its original design. This makes maintenance more difficult and reduces the software 
quality. Refactoring can then help to bring the system back to its original design and into a more maintainable state, 
improving code quality in the process.

However, manual refactoring without any tool support can be error-prone and time-consuming. There are various tools 
available for supporting elementary refactorings like renaming a variable or introducing an additional parameter to a 
function, often built into the used \emph{Integrated Development Environment} (IDE) itself. But even with tool support, 
manual refactoring can still be too complicated or just tedious, and tool support for automating refactoring tasks is 
desirable in a number of cases.

In this article we're going to highlight some recent and not-so-recent contributions in the field of automatic 
refactoring, ranging from simple tasks like making code more compact \cite{sparta}, to more complicated tasks like 
introducing object-orientation into a C codebase \cite{cpp}.
%We will also investigate the benefit from refactoring a software through replacing conditionals by using polymorphism 
%\cite{polymorphism}, as well as the approach of using design differencing for automated refactoring \cite{design-diff}.


\section{Automated Refactoring Approaches}

This section will give an overview of each paper by summarizing the main points.

\pf{Should we include the results in the following subsections, or make a dedicated section after this one?}

\subsection{Restructuring Legacy C Code into C++}

This is an older paper from 1999 by Richard Fanta and VÃ¡clav Rajlich of \emph{Wayne State University} in Detroit, MI, 
USA~\cite{cpp}. They did a case study on the Mosaic browser, an early web browser implemented in C. Their approach uses 
a number of discrete refactorings. By combining those, a C \code{struct} or a number of related variables can be 
transformed into a C++ class, with related functions becoming member functions of that class.

The following two sections will briefly explain the implemented refactorings and their use in the whole restructuring 
process, respectively.

\subsubsection{Refactoring Tools}

This section briefly summarizes the implemented tools used in the restructuring process. Each tool has specific 
restrictions placed on when it can be applied, which simplifies the tool and makes sure the code is in a consistent 
state after its application.

The \textbf{variable insertion} tool inserts a selected variable into a class as a static or non-static member. The 
programmer needs to specify the variable which should be inserted, as well as the class---for a static variable---or 
the instance---for a non-static variable---it should be inserted into.

Another tool \textbf{makes access to a non-local variable explicit} by introducing an explicit parameter for the 
accessed variable, redirecting all accesses inside the function to that parameter, and finally adding an actual 
parameter for the variable at every call of the function. The same is also possible in reverse to \textbf{make access 
implicit}.

To \textbf{add a parameter} to a function, another tool is used that adds the parameter to the formal parameter list. 
After selecting the instance to be passed as the new parameter for each call, the tool inserts that instance as a 
parameter to the call.

Finally there is a tool for \textbf{changing the access specifier of a class member}, which just checks that a certain 
change doesn't make the code inconsistent.

\subsubsection{Restructuring Scenario}

The refactoring tools described in the previous section are used at various steps in the whole process. The complete 
restructuring process thus involves both actions by a human as well as use of the tools, and is divided into three 
phases.

\begin{enumerate}
  \item Data-only classes are created from a number of variables, if necessary. In case there is already a C 
  \code{struct}, this step can be skipped.
  
  \item After creating the desired classes, possible clones are removed. Clones may result from the same domain concept 
  being implemented at various places in the code.
  
  \item Lastly, the user specifies functions which should be added to a class as a member function. These may be 
  functions that have the target class as a parameter, access it through a global variable, or have individual members 
  of the target class as parameters.
\end{enumerate}

\subsection{Conditionals vs Polymorphism}

\lk{TODO definition and comparison}

\subsection{Design Differencing}

\lk{TODO definition and comparison}

\subsection{Spartanizer}

\lk{PF: TODO definition and comparison}


\section{Conclusion}

Text


\section*{Acknowledgments}

Text


\bibliographystyle{IEEEtran}
\bibliography{AutomatedRefactoring}

% TODO Place appropriately
%\balance

% that's all folks
\end{document}
